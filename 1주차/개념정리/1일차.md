# [스택, 큐, 리스트, 해시맵 정리]

## 스택 (Stack)

### 💡 주요 개념

스택은 데이터를 하나씩 쌓아 올린 형태의 자료구조로, 한쪽 끝에서만 자료를 넣고 뺄 수 있는 LIFO(Last In First Out) 형식이다.

데이터를 집어넣는 `push`, 데이터를 추출하는 `pop`, 맨 나중에 집어넣은 데이터를 확인하는 `peek` 등의 작업을 할 수 있다.

<aside>

서로 관계가 있는 여러 작업을 연달아 수행하면서 **이전의 작업 내용을 저장해 둘 필요가 있을 때** 주로 사용된다.

</aside>

## 큐 (Queue)

### 💡 주요 개념

데이터를 집어넣을 수 있는 선형(linear) 자료구조로, 먼저 집어넣은 데이터가 먼저 나오는 FIFO(First In First Out) 형식이다.

데이터를 집어넣는 `enqueue`, 데이터를 추출하는 `dequeue` 등의 작업을 할 수 있다.

<aside>

순서대로 처리해야 하는 작업을 임시로 저장해두는 **버퍼(buffer)**로서 많이 사용된다.

</aside>

## 리스트 (List)

### 💡 주요 개념

리스트는 데이터를 순서가 있는 수정 가능한 객체의 집합으로, 수정, 삭제, 추가가 가능하다.

JS에서 배열은 리스트 형태의 고수준 객체로, **동적 배열**이다.

- 동적 배열이란?
  1. 기본 배열의 단점을 보완한 자료구조로, 기본적으로 배열이 가지는 특징을 그대로 가진다.
  2. 초기에 고정된 크기를 할당받으며 생성되고, 초기에 지정한 크기를 넘어서면 동적으로 크기를 늘린다.
  3. 각 원소의 인덱스가 연속적이지 않아도 되고, 원소들 사이에 빈자리(undefined)가 있어도 된다.

<aside>

배열 혹은 스택의 기능으로 사용할 수 있지만, **큐의 기능을 제공하지 못한다.**

</aside>

### 💡 주요 메서드

```jsx
// .concat() : 여러 개의 배열을 이어 붙여서 합친 결과를 반환. O(N)
let arr1 = [1, 2, 3, 4, 5];
let arr2 = [6, 7, 8, 9, 10];
let arr = arr1.concat(arr2, [11, 12], [13]);

arr; // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]

// .slice(left, right) : 특정 구간의 원소를 꺼낸 배열을 반환. O(N)
let arr = [0, 1, 2, 3, 4];
let result = arr.slice(2, 5);

result; // [2, 3, 4]

// indexOf() : 특정한 값을 가지는 원소의 첫째 인덱스를 없으면 -1 반횐. O(N)
let arr1 = [1, 2, 3, 4, 5];

arr.indexOf(2); // 3
```

## 해시맵 (HashMap)

### 💡 주요 개념

해시맵(HashMap)은 맵(Map) 인터페이스를 구현한 대표적인 맵(Map) 컬렉션이다.

맵(Map) 인터페이스를 상속하고 있기에 맵(Map)의 성질을 그대로 가지고 있다.

- 맵이란?
  맵은 키와 값으로 구성된 Entry 객체를 저장하는 구조를 가지고 있는 자료구조이다. 여기서 키와 값은 모두 객체이다. 값은 중복 저장될 수 있지만 키는 중복 저장될 수 없다. 만약 기존에 저장된 키와 동일한 키로 값을 저장하면 기존의 값은 없어지고 새로운 값으로 대치된다.

해시맵(HashMap)은 이름 그대로 해싱(Hashing)을 사용하기 때문에 많은 양의 데이터를 검색하는 데 있어서 뛰어난 성능을 보인다.

- 해시맵의 장단점은?
- 해시맵을 사용하는 경우
  - 데이터 검색이 빈번한 경우
    - 해시맵은 탐색 속도가 빠르므로, 데이터 검색이 빈번한 경우에 유용합니다. 예를 들어, 사용자가 검색어를 입력하면 해당 검색어를 포함하는 데이터를 빠르게 찾아서 보여줄 수 있습니다.
  - 데이터의 중복을 피해야 하는 경우
    - 해시맵은 각 키(Key) 값이 유일해야 한다는 제약 조건이 있어, 중복된 데이터를 저장하지 않습니다. 이러한 특징 때문에, 데이터의 중복을 피해야 하는 경우에 해시맵을 사용하는 것이 좋습니다.
  - 다양한 데이터 타입을 다루어야 하는 경우
    - 해시맵은 제네릭(Generic)을 이용하여 다양한 데이터 타입을 다룰 수 있습니다. 따라서, 다양한 데이터 타입을 다루어야 하는 경우에도 해시맵을 사용할 수 있습니다.
  - 대용량 데이터 처리가 필요한 경우
    - 해시맵은 대용량 데이터를 빠르게 처리할 수 있습니다. 이러한 특징 때문에, 대용량 데이터 처리가 필요한 경우에 해시맵을 사용하는 것이 좋습니다.

<aside>

데이터 검색이 빈번하거나 데이터의 중복을 피해야 하며, 다양한 데이터 타입을 다루어야 하거나 대용량 데이터 처리가 필요한 경우에는 해시맵을 사용하는 것이 유용하다!

</aside>

### 💡 주요 메서드

- put(K key, V value) : Key-Value 쌍을 HashMap에 추가합니다. 만약 Key 값이 이미 존재할 경우, 해당 Key의 Value를 새로운 값으로 덮어씁니다.
- get(Object key) : Key에 해당하는 Value를 반환합니다. 만약 Key 값이 존재하지 않을 경우, null을 반환합니다.
- remove(Object key) : Key에 해당하는 Key-Value 쌍을 HashMap에서 삭제합니다. 삭제된 Value를 반환합니다.
- size() : HashMap에 저장된 Key-Value 쌍의 개수를 반환합니다.
- containsKey(Object key) : HashMap에 Key 값이 존재하는지 확인합니다. 존재하면 true를 반환합니다.
- containsValue(Object value) : HashMap에 Value 값이 존재하는지 확인합니다. 존재하면 true를 반환합니다.
- keySet() : HashMap에 저장된 Key 값을 Set으로 반환합니다.
- values() : HashMap에 저장된 Value 값을 Collection으로 반환합니다.
- entrySet() : HashMap에 저장된 Key-Value 쌍을 Entry 객체로 묶어서 Set으로 반환합니다.

### 💡 시간복잡도

- 탐색/검색 : O(1)
- 추가/삭제 : O(1)

<aside>

해시맵은 데이터의 크기에 상관없이 빠른 속도를 보장하기 때문에, 대용량 데이터 처리가 필요한 경우나 데이터 검색이 빈번한 경우 등에 많이 사용됩니다.

</aside>
